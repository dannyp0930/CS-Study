영상: https://www.youtube.com/playlist?list=PLD8rdlfZeJk6evHY9NsnBqXKrreNbTqFv

### 알고리즘

> - 문제를 해결하기 위한 절차를 기술한 것
> - 누구나 정해진 절차대로 실행할 수 있어야 한다.
> - 누구나 동일한 입력값이 주어지면 이 절차대로 실행하면 동일한 출려값을 얻을 수 있어야 한다.
> - 일정한 시간안에 출력값을 구할 수 있어야 한다.

- 순서대로 정의된 절차
  - 문명한 순서가 있어야 한다.
  - 한 동작을 실행하면 다음에 실행할 동작이 무엇인지 분명 해야 한다.
- 명확성
  - 모든 동작은 명확하게 정의되어야 한다.
  - 모든 동작은 실행 가능해야 한다.
- 반드시 원하는 결과가 나와야 한다.
- 일정한 시간 안에 실행되어야 한다.



#### 구조

1. 순차적 구조(sequential structure)

   ![image-20220107134935385](알고리즘,그래프.assets/image-20220107134935385.png)

2. 분기 구조(branch)

   ![image-20220107135124726](알고리즘,그래프.assets/image-20220107135124726.png)

3. 반복 구조(retetition)

   ![image-20220107135455646](알고리즘,그래프.assets/image-20220107135455646.png)

4. 점프 구조(jump)

   ![image-20220107135532380](알고리즘,그래프.assets/image-20220107135532380.png)



#### 기술 방법

1. 플로우차트(flowchart)
2. 프로그램 언어의 코드
   - 이것은 특정 프로그램 언어의 문법을 알아야 된다.
   - 또 코드 수준으로 자세히 적을 필요는 없다.
3. Pseudocode
   - 프로그램 언어의 코드 전 단계로 프로그램 언어들이 사용하는 구조를 그대로 이용한다.



#### 예시

> 이진 탐색
>
> 리스트트의 키 값이 정렬되어 있다면 순차 검색 보다 빠른 시간 안에 검색할 수 있다.
>
> [1, 3, 4, 5, 10, 13, 15, 20, 23, 32]

1. 언어로 기술하기

   먼저 찾고자 하는 키 값을 리스트의 중간에 위치한 값, 13과 비교한다. 만약 찾고자 하는 키 값이 13 보다 작으면 이 값은 13보다 왼쪽에 위치하고 있으며, 13보다 크다면 13의 오른쪽에 위치하고 있다. 따라서 다음 단계에서 13보다 왼쪽에 있는 값들, 혹은 오른쪽에 있는 값들을 가지고 같은 절차를 반복한다.

2. 알고리즘

   ```pseudocode
   while (리스트 구간의 크기 > 0)
   	구간의 중간값을 구한다.
   	if (구간의 중간값 = 키값)
   		탐색 종료
   	else if (구간의 중간값 > 키값)
   		오른쪽 구간 선택
   	else
   		왼쪽 구간 선택
   ```

3. Pseudocode

   ```pseudocode
   get Target, n and [N1, N2, ..., Nn]
   begin = 1
   end = n
   Found = NO
   while (Found = NO and begin <= end)
   	m = (begin + end) / 2
   	if (target = Nm)
   		print Nm
   		Found = YES
   	else
   		if (target < Nm)
   			end = m - 1
   		else
   			begin = m + 1
   if (Found = NO)
   	print "can't find target"
   stop
   ```

   

### 오일러 순환과 해밀턴 순환

#### 오일러 순환

- 오일러 경로(Eulerian path) : 그래프 G의 모든 연결선을 한번만 방문하는 경로
- 오일러 순환(Eulerian cycle 혹은 Circuit) : 시작점과 끝점이 동일한 오일러 경로
- 오일러 그래프 : 오일러 순환이 존재하는 그래프



#### 차수(degree)

- 정점 u에 접합된 연결선의 수
- 차수는 deg(u)와 같이 표기하기도 한다.



#### 오일러 경로를 갖기 위한 필요 충분 조건

> 2개 이상의 정점을 갖는 루프가 없는 연결 그래프에서 홀수 차수(odd degree)를 갖는 정점이 하나도 없거나 오직 두 개만 존재해야 한다.
>
> 특히 모든 정점이 짝수 차수를 가지면 오일러 순환이 존재하며, 이 그래프는 오일러 그래프이다.



#### 해밀턴 순환

- 해밀턴 경로(Hamiltonian path): 그래프 G에서 모든 정점을 정확히 한 번만 지는 경로
- 해밀턴 순환(Hamiltonian cycle 혹은 circuit) : 시작점과 끝점이 같은 해밀턴 경로



#### 해밀턴 순환을 찾는 알고리즘

![image-20220302000753710](알고리즘,그래프.assets/image-20220302000753710.png)

####  

#### 해밀턴 순환 알고리즘

- Exhaustive Search
- 탐색해야 되는 경로의 수
  - 트리의 leaf의 수
- 트리의 높이 : n + 1
- Leaf의 수 : 2<sup>n</sup>



#### 해밀턴 순환 찾는 알고리즘 복잡도

- 알고리즘 복잡도 : O(X<sup>n</sup>) (n : 정점의 수)
- 복잡도 함수는 다항식이 아니라 지수식이다.
- 몹시 어려운 문제
- 유사한 복잡도 문제
  - 암호 해독
  - 바둑(혹은, 장기, Chess 등)
  - Bin packing 등



#### 방문 판매원 문제(Traveling Salesman Problem)

- 연결선에는 비용이 주어진다. (weighted edge)
- 일반적으로 완전 그래프
- 이 그래프에서 비용이 최소가 되는 해밀턴 순환을 찾는 문제

![image-20220302001227100](알고리즘,그래프.assets/image-20220302001227100.png)



#### TSP 알고리즘1

모든 해밀턴 순환을 찾아서 합한 비용이 가장 작은 순환을 선택한다. :arrow_right: Exhaustive search



#### TSP 알고리즘2

> 단순 TSP 알고리즘
>
> 1. 하나의 정점을 선택하여 출발점으로 한다.
> 2. 이 정점에 연결된 연결선의 비용이 가장 작은 정점을 선택한다.
> 3. 이 정점에서부터 아직 선택되지 않은 정점들 중에서 연결선의 비용이 가장 작은 정점을 선택한다.
> 4. 모든 정점을 선택할 때 까지 2와 3의 절차를 반복한다.



### 기본 용어

-

### 그래프 채색
-

### 최소신장 트리
-

### 최단경로 알고리즘
-
