영상: https://www.youtube.com/playlist?list=PLD8rdlfZeJk6evHY9NsnBqXKrreNbTqFv

### 알고리즘

> - 문제를 해결하기 위한 절차를 기술한 것
> - 누구나 정해진 절차대로 실행할 수 있어야 한다.
> - 누구나 동일한 입력값이 주어지면 이 절차대로 실행하면 동일한 출려값을 얻을 수 있어야 한다.
> - 일정한 시간안에 출력값을 구할 수 있어야 한다.

- 순서대로 정의된 절차
  - 문명한 순서가 있어야 한다.
  - 한 동작을 실행하면 다음에 실행할 동작이 무엇인지 분명 해야 한다.
- 명확성
  - 모든 동작은 명확하게 정의되어야 한다.
  - 모든 동작은 실행 가능해야 한다.
- 반드시 원하는 결과가 나와야 한다.
- 일정한 시간 안에 실행되어야 한다.



#### 구조

1. 순차적 구조(sequential structure)

   ![image-20220107134935385](알고리즘,그래프.assets/image-20220107134935385.png)

2. 분기 구조(branch)

   ![image-20220107135124726](알고리즘,그래프.assets/image-20220107135124726.png)

3. 반복 구조(retetition)

   ![image-20220107135455646](알고리즘,그래프.assets/image-20220107135455646.png)

4. 점프 구조(jump)

   ![image-20220107135532380](알고리즘,그래프.assets/image-20220107135532380.png)



#### 기술 방법

1. 플로우차트(flowchart)
2. 프로그램 언어의 코드
   - 이것은 특정 프로그램 언어의 문법을 알아야 된다.
   - 또 코드 수준으로 자세히 적을 필요는 없다.
3. Pseudocode
   - 프로그램 언어의 코드 전 단계로 프로그램 언어들이 사용하는 구조를 그대로 이용한다.



#### 예시

> 이진 탐색
>
> 리스트트의 키 값이 정렬되어 있다면 순차 검색 보다 빠른 시간 안에 검색할 수 있다.
>
> [1, 3, 4, 5, 10, 13, 15, 20, 23, 32]

1. 언어로 기술하기

   먼저 찾고자 하는 키 값을 리스트의 중간에 위치한 값, 13과 비교한다. 만약 찾고자 하는 키 값이 13 보다 작으면 이 값은 13보다 왼쪽에 위치하고 있으며, 13보다 크다면 13의 오른쪽에 위치하고 있다. 따라서 다음 단계에서 13보다 왼쪽에 있는 값들, 혹은 오른쪽에 있는 값들을 가지고 같은 절차를 반복한다.

2. 알고리즘

   ```pseudocode
   while (리스트 구간의 크기 > 0)
   	구간의 중간값을 구한다.
   	if (구간의 중간값 = 키값)
   		탐색 종료
   	else if (구간의 중간값 > 키값)
   		오른쪽 구간 선택
   	else
   		왼쪽 구간 선택
   ```

3. Pseudocode

   ```pseudocode
   get Target, n and [N1, N2, ..., Nn]
   begin = 1
   end = n
   Found = NO
   while (Found = NO and begin <= end)
   	m = (begin + end) / 2
   	if (target = Nm)
   		print Nm
   		Found = YES
   	else
   		if (target < Nm)
   			end = m - 1
   		else
   			begin = m + 1
   if (Found = NO)
   	print "can't find target"
   stop
   ```

   

### 오일러 순환과 해밀턴 순환
-

### 기본 용어
-

### 그래프 채색
-

### 최소신장 트리
-

### 최단경로 알고리즘
-
